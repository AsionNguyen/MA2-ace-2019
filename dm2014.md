---
layout: post
title: Devoir Maison 2014
---

<script src='js/dm2014.js'></script>

Ce devoir est √† r√©aliser dans une feuille de calcul Sage. Utilisez les
cellules ordinaires pour faire les calculs, et les cellules de texte
pour ajouter vos commentaires et les r√©ponses aux questions. Rappel‚ÄØ:
vous pouvez saisir des formules au format LaTeX entre les symboles `$`
(dollar).

Envoyez votre travail complet par mail. Vous pouvez soit l'exporter au
format `.sws` (*¬´‚ÄØSave worksheet to a file...‚ÄØ¬ª*), soit donner le lien
du worksheet sur <http://sage.math.uvsq.fr/> (et uniquement sur ce
serveur).


## Cryptanalyse alg√©brique

La cryptanalyse alg√©brique est une m√©thode tr√®s g√©n√©rale pour attaquer
les syst√®mes cryptographiques, en particulier les syst√®mes
sym√©triques. De fa√ßon g√©n√©rale, cela consiste √† mod√©liser le secret
par les inconnues d'un anneau polynomial (le plus souvent √†
coefficients dans $$ùîΩ_2$$), √† encoder les relations entre les
inconnues et les donn√©es connues (par ex., les paires clair-chiffr√©)
dans un syst√®me polynomial, et √† r√©soudre ce dernier par des
techniques g√©n√©riques, tels les *SAT solvers* ou les bases de Gr√∂bner.

Dans ce devoir, nous allons √©tudier des cas particuliers de chiffrement
par flot, qui se mod√©lisent tr√®s bien par des syst√®mes polyn√¥miaux.

On rappelle qu'un syst√®me de chiffrement par flot n'est rien d'autre
qu'un g√©n√©rateur pseudo-al√©atoire avec clef‚ÄØ: il prend en entr√©e une
donn√©e secr√®te, et il g√©n√®re en sortie un flux infini de symboles
(typiquement des bits). Le chiffrement se r√©alise en ajoutant le flot
au clair, le d√©chiffrement en le soustrayant. Compromettre un syst√®me
de chiffrement par flot revient √† pr√©dire la suite pseudo-al√©atoire √†
partir d'une partie de ses bits‚ÄØ; dans toutes les attaques que nous
allons r√©aliser, nous retrouverons toujours la clef secr√®te, ce qui
permet de pr√©dire la totalit√© de la suite.


## LFSR

Un *Linear Feedback Shift Register* (LFSR) est un g√©n√©rateur
pseudo-al√©atoire tr√®s simple, qui peut √™tre r√©alis√© tr√®s efficacement
par un circuit √©lectronique.

Un LFSR est compos√© d'une suite de registres binaires, qui commencent
dans un √©tat initial (secret ou pas). √Ä chaque it√©ration la valeur
dans le registre le plus √† droite sort du LFSR pour aller constituer
le bit suivant de la suite pseudo-al√©atoire‚ÄØ; les valeurs de tous les
registres sont ensuites d√©cal√©es d'une position vers la droite, et les
registres d'un sous ensemble pr√©d√©termin√© (les *taps*) sont *XOR√©s*
(additionn√©s modulo 2) pour obtenir la nouvelle valeur du registre le
plus √† gauche. Ceci est sch√©matis√© dans la figure ci-dessous.

![](http://upload.wikimedia.org/wikipedia/commons/1/16/LFSR-F16.gif)

Dit autrement, la suite g√©n√©r√©e par un LFSR est une *suite r√©currente
lin√©aire* √† coefficients dans $$ùîΩ_2$$. Dans l'exemple ci-dessus, la
suite est d√©finie par l'√©quation

$$x_{n+16} = x_n + x_{n+2} + x_{n+3} + x_{n+5}.$$

1. Un LFSR peut √™tre repr√©sent√© par un polyn√¥me avec autant de
   variables que de registres. √âcrivez une fonction (voir les
   [notes sur les fonctions](python#fonctions)) qui prend en entr√©e
   
   - un polyn√¥me √† $$n$$ variables,
   - une liste contenant les $$n$$ valeurs initiales $$(x_0,\dots,x_{n-1})$$,
   - un entier $$i$$,
   
   et qui renvoie $$x_i$$, le $$i$$-√®me bit de la sortie du LFSR.

2. Comme le nom l'indique, un LFSR est une fonction lin√©aire de ses
   entr√©es. Dire quelle est la repr√©sentation matricielle de la
   fonction
   
   $$(x_0,\dots,x_{n-1}) ‚Ü¶ (x_1,\dots,x_n).$$
   
   √âcrire une fonction qui prend en entr√©e
   
   - une matrice $$n√ón$$ repr√©sentant un LFSR
   - une liste contenant les $$n$$ valeurs initiales $$(x_0,\dots,x_{n-1})$$,
   - un entier $$i$$,
   
   et qui renvoie $$(x_i,\dots,x_{n-1+i})$$. Il est conseill√© de
   consulter la
   [documentation Sage sur les matrices](http://www.sagemath.org/doc/reference/matrices/sage/matrix/constructor.html)

3. Le notebook permet de mesurer les performances du code Sage √†
   l'int√©rieur d'une cellule. La *clef magique* `%time`, toute seule
   au d√©but d'une cellule, mesure le temps pass√© √† en ex√©cuter le
   contenu.
   
   ~~~
   %time
   a = sum(range(10^7))
   ~~~
   
   Comparez les deux fonctions √©crites pr√©c√©demment √† l'aide de
   `%time`. √Ä partir de quelle valeur de $$i$$ la diff√©rence devient
   apparente‚ÄØ? Quelle est la meilleure fonction, et pourquoi‚ÄØ?
   
   **Remarque‚ÄØ:** la fonction bas√©e sur la repr√©sentation matricielle
   devrait pouvoir traiter des $$i \sim 10^{1000}$$ sans
   difficult√©. Si cela n'est pas le cas, r√©fl√©chissez davantage, faute
   de quoi vous risquez de ne pas pouvoir aborder les questions
   suivantes.

4. Soit $$L$$ la matrice associ√©e √† un LFSR, le *polyn√¥me minimal* du
   LFSR est le polyn√¥me minimal de $$L$$. Montrer que le polyn√¥me
   minimal d√©finit uniquement le LFSR.
   

## Cryptanalyse des LFSR

On suppose maintenant qu'on a acc√®s √† (une partie de) la sortie d'un
LFSR √† $$n$$ registres, mais qu'on ne conna√Æt pas son polyn√¥me
minimal. Le but de la cryptanlyse va √™tre de retrouver le polyn√¥me
secret d√©finissant le LFSR.

1. Soit $$x_0,x_1\dots$$ la suite g√©n√©r√©e par le LFSR, et soit $$S$$
   la s√©rie formelle d√©finie par
   
   $$S = \sum_{i‚â•0} x_i X^i.$$
   
   Soit $$p$$ de degr√© $$n$$ le polyn√¥me minimal du LFSR, on d√©finit
   
   $$\tilde{p} = X^n p(1/X)$$
   
   c'est √† dire le polyn√¥me obtenu en *renversant* les coefficients de
   $$p$$. Prouver que
   
   $$R = S¬∑\tilde{p}$$
   
   est un polyn√¥me de degr√© $$<n$$.


Soit $$m‚â•2n$$, et soit $$s = S \mod X^m$$. Retrouver $$R$$ et
$$\tilde{p}$$ √† partir de $$s$$ est un probl√®me
d'[approximation de Pad√©](http://fr.wikipedia.org/wiki/Approximant_de_Pad%C3%A9).
L'√©galit√© prouv√©e au point pr√©c√©dent montre que
   
$$R = s¬∑\tilde{p} + q¬∑X^m.$$

Les polyn√¥mes $$R$$ et $$\tilde{p}$$ (et $$q$$) peuvent √™tre calcul√©s
par une variante de l'algorithme d'Euclide √©tendu.  Il suffit, en
effet, d'ex√©cuter l'algorithme usuel avec $$s$$ et $$X^m$$ en entr√©e,
en arr√™tant le calcul d√®s que l'on trouve un reste de degr√© $$<n$$.
   
**Exemple‚ÄØ:** prenons $$n=3$$ et consid√©rons la suite
$$(0,1,1,1,0,0,1,0)$$, correspondant √† la s√©rie formelle
   
$$S = X + X^2 + X^3 + X^6 + O(X^8)$$
   
Le pgcd √©tendu entre $$X^8$$ et $$s$$ donne successivement les
relations
   
- $$X^2¬∑s + X^8 = X^5 + X^4 + X^3$$,
- $$(X^3+X^2+1)¬∑s + (X+1)¬∑X^8 = X^2 + X$$‚ÄØ;
   
on d√©duit $$\tilde{p} = X^3 + X^2 + 1$$ et $$R = X^2 + X$$, la
v√©rification est imm√©diate.

La preuve que $$R$$ appara√Æt effectivement dans la suite des restes de
l'algorithme d'Euclide est simple, mais technique, c'est pourquoi nous
√©vitons de la d√©tailler. Le lecteur int√©ress√© pourra se renseigner sur
la th√©orie des
[sous-r√©sultants](http://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultants).
   
2. √âcrire un fonction qui prend en entr√©e la suite $$s$$ et le degr√©
   $$n$$ et qui calcule le polyn√¥me minimal $$p$$.
   
   **Suggestion‚ÄØ:** Vous pouvez vous inspirer de la fonction
   [vue en TD](http://localhost:4000/exercises.html#polynmes--une-variable).
   
   **Suggestion‚ÄØ:** Berlekamp-Massey est un autre algorithme
   permettant de calculer le polyn√¥me minimal $$p$$ √† partir de la
   connaissance d'au moins $$2n$$ bits de la sortie du LFSR... et il
   est d√©j√† implant√© dans Sage‚ÄØ!  Servez-vous-en pour vous aider √†
   v√©rifier vos calculs.

3. Utilisez votre fonction pour trouver le polyn√¥me minimal de la
   suite
   
   1,0,1,1,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,...
   
   (oui, $$n$$ n'a pas √©t√© pr√©cis√©, il ne s'agit pas d'une erreur).
{:start='2'}


## G√©n√©rateurs non-lin√©aires

Il a toujours √©t√© reconnu que la lin√©arit√© des LFSR constitue une
faiblesse cryptographique pour la conception des syst√®mes de
chiffrement par flot. N√©anmoins, on a cru que le simple ajout d'une
couche non-lin√©aire pourrait suffire √† d√©finir un syst√®me
robuste. Nous allons voir ici que cela n'est pas sans risques.

Soit $$f$$ la *fonction bool√©enne* (c.-√†-d., √† valeurs dans $$ùîΩ_2$$)

$$f = \sum_{i=0}^7 x_i x_{15-i}$$

et soit $$L$$ le LFSR d√©fini par le polyn√¥me

$$x^{16} + x^5 + x^3 + x^2 + 1.$$

On d√©finit un g√©n√©rateur pseudo-al√©atoire comme suit‚ÄØ:

$$x_i = f(L^i(s_0,\dots,s_{15})),$$

o√π $$(s_0,\dots,s_{15})$$ est une clef secr√®te de 16 bits.

1. √âcrire une fonction qui prend en entr√©e
   
   - la clef secr√®te ($$s_0,\dots,s_{15}$$),
   - un entier $$i$$,
   
   et qui renvoie le bit $$x_i$$.

Dans le cadre de notre attaque alg√©brique, on va supposer qu'on a
intercept√© une certaine quantit√© de bits de la sortie, et on veux
retrouver la clef secr√®te. Nous allons utiliser comme exemple, la
suite de bits suivante, qui correspond aux 100 premiers bits de la
sortie‚ÄØ:

<div id='out16' style='overflow-x:scroll;font-size:smaller'></div>

2. On consid√®re l'anneau de polyn√¥mes $$ùîΩ_2[x_0,\dots,x_{n-1}]$$. Quel
   est l'id√©al de la vari√©t√© $$V=ùîΩ_2^n$$‚ÄØ?

3. Mod√©liser les bits secrets $$(s_0,\dots,s_{15})$$ par autant de
   variables d'un anneau polynomial. √âcrire un syst√®me d'√©quations
   mettant en rapport les variables secr√®tes avec les bits de sortie,
   et le r√©soudre √† l'aide des bases de Gr√∂bner. N'oubliez pas
   d'ajouter les √©quations vues au point pr√©c√©dent.
   
   **Attention‚ÄØ:** plus on conna√Æt de bits, plus on conna√Æt
   d'√©quations, moins de temps prendra le calcul de la base de
   Gr√∂bner. D'un autre c√¥t√©, le calcul de chaque √©quation prend lui
   aussi du temps. Aidez-vous avec `%time` pour trouver le meilleur
   compromis. Le choix de l'ordre monomial a lui aussi un poids
   important sur le calcul de la base de Gr√∂bner, quel ordre est le
   plus efficace‚ÄØ?
   
   **Solution‚ÄØ:** pour vous aider √† tester votre code, la suite donn√©e
   est g√©n√©r√©e al√©atoirement √† chaque rechargement de cette page. La
   clef secr√®te pour cette suite est...
   (<span id='in16' style="color:white"></span>).
{:start='2'}

Un secret de 16 bits, c'est loin d'√™tre une taille
cryptographique. Attaquons maintenant un secret de 80 bits, ce qui est
largement infaisable par recherche exhaustive.

On va prendre la fonction $$f$$ d√©finie par

$$f = \sum_{i=0}^{39} x_i x_{79-i},$$

et le LFSR d√©fini par le polyn√¥me

$$x^{80} + x^9 + x^4 + x^2 + 1.$$

Le g√©n√©rateur est d√©fini comme auparavant par la composition de $$f$$ avec $$L^i$$.

3. √âtant donn√©e la suite initiale de bits
   
   <div id='out80' style='overflow-x:scroll;font-size:smaller'></div>
   
   trouver la clef secr√®te.
   
   **Attention‚ÄØ:** correctement r√©alis√©, ce calcul n√©cessite de ~4GB
   de m√©moire vive. Il est recommand√© de l'effectuer sur
   <http://sage.math.uvsq.fr/>, ou sur une autre machine suffisamment
   puissante. Il peut prendre une vingtaine de minutes √† compl√©ter‚ÄØ:
   armez-vous de patience (rappel‚ÄØ: si besoin *¬´‚ÄØRestart worksheet‚ÄØ¬ª*
   dans le menu ¬´‚ÄØAction‚ÄØ¬ª arr√™te le calcul en cours).
   
   **Suggestion‚ÄØ:** avant de vous attaquer √† ce probl√®me, il peut √™tre
   judicieux de faire des essais avec des syst√®mes similaires ayant un
   secret plus petit (par exemple 32 ou 64 bits). Ceci vous permettra
   de v√©rifier que votre code est capable d'attaquer un probl√®me de
   grande taille.

   **Solution‚ÄØ:** Encore une fois, la clef secr√®te est g√©n√©r√©e √†
   chaque rechargement. Dans ce cas, elle est...
   (<span id='in80' style="color:white;word-wrap:break-word;font-size:smaller"></span>).
{:start='4'}


<script>
(function() {
  var state = [];
  for (var i = 0; i < 16; i++)
	state.push(Math.random() > 0.5 ? 0 : 1);
  var taps = [0, 2, 3, 5];
  $('#in16').innerHTML = state.join(',');
  $('#out16').innerHTML = window.generator(state,taps,100).join(',');
  
  state = [];
  for (var i = 0; i < 80; i++)
	state.push(Math.random() > 0.5 ? 0 : 1);
  taps = [0, 2, 4, 9];
  $('#in80').innerHTML = state.join(',');
  $('#out80').innerHTML = window.generator(state,taps,4000).join(',');
})();
</script>


## G√©n√©rateurs hautement non-lin√©aires

Dans l'exemple pr√©c√©dent, la vuln√©rabilit√© du syst√®me est due au bas
degr√© des √©quations en jeu. Cette vuln√©rabilit√© est connue depuis
longtemps, et c'est pourquoi des syst√®mes cryptographiques r√©els ont
utilis√© des fonctions non-lin√©aires de haut degr√©. Si ces syst√®mes ont
pendant longtemps √©t√© consid√©r√©s s√ªrs, au d√©but des ann√©es 2000 une
suite d'attaques astucieuses ont boulevers√© le monde du chiffrement
par flot.

Consid√©rons la fonction bool√©enne

$$f = x_{31} + \sum_{i=0}^{14} x_i x_{29-i} + x_2 x_6 x_{10} x_{13}
+ x_2 x_3 x_5 x_7 x_{11} x_{13} x_{17} x_{19} x_{23} x_{29} x_{31} +
\prod_{i=0}^{14} x_i,$$

et le LFSR d√©fini par le polyn√¥me

$$x^{32} + x^7 + x^3 + x^2 + 1.$$

Comme auparavant, on d√©finit un g√©n√©rateur pseudo-al√©atoire par

$$x_i = f(L^i(s_0,\dots,s_{31})).$$


1. Lisez
   [ce papier de Courtois et Meier](http://www.minrank.org/toyolili.ps)
   et mettez en pratique l'attaque qu'y est d√©crite.
   
   **Attention‚ÄØ:** l'anneau de polyn√¥mes standard en Sage se r√©v√®le
   bien trop lent pour mettre en pratique cette attaque. Il sera
   opportun d'utiliser une implantation sp√©cifique pour les *polyn√¥mes
   bool√©ens*.
   
   En rempla√ßant
   
	   PolynomialRing(GF(2), n, 's')
   
   par
   
	   BooleanPolynomialRing(n, 's')
   
   on obtient un objet qui repr√©sente l'anneau quotient
   
   $$ùîΩ_2[s_0,\dots,s_{n-1}] / I(ùîΩ_2^n).$$
   
   la majorit√© des fonctionnalit√©s qui √©taient d√©finies pour l'anneau
   de polyn√¥mes classique le sont encore, mais l'arithm√©tique est
   beaucoup plus rapide, quoique plus gourmande en m√©moire.
   
   En utilisant cette structure, l'attaque devrait √™tre r√©alisable en
   une dizaine de minutes.

